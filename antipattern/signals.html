<!doctype html><html lang=en><head><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta http-equiv=content-security-policy content="frame-src https://www.buymeacoffee.com; style-src 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://cdn.rawgit.com 'self'; script-src 'sha256-imF8GK2COF0FH3k9XZpauIkklApKaavS3S5BhNoXbio=' 'sha256-cZF+Uee35x4Ntz8KyGTRwEq74vIlvLgxfBw7ARDKY0o=' 'sha256-nP0EI9B9ad8IoFUti2q7EQBabcE5MS5v0nkvRfUbYnM=' https://cdn.jsdelivr.net https://cdnjs.buymeacoffee.com https://code.jquery.com https://cdnjs.cloudflare.com https://cdn.rawgit.com https://pagead2.googlesyndication.com 'self'; img-src https://repository-images.githubusercontent.com https://cdn.buymeacoffee.com https://img.shields.io 'self'"><meta name=keywords content="Django,web,programming,antipattern,pattern,troubleshooting,software design,signals,updates,modeling,django-signals"><meta name=author content="Willem Van Onsem"><meta name=description content="A set of Django (anti)patterns: patterns and things to avoid when building a web application with Django."><meta name=twitter:image:src content="https://repository-images.githubusercontent.com/257009680/7a954900-2f5d-11eb-8d0a-c8af0596107f"><meta name=og:title content="Signals"><meta name=og:image content="https://repository-images.githubusercontent.com/257009680/7a954900-2f5d-11eb-8d0a-c8af0596107f"><meta name=og:image:alt content="A prohibition sign in the Django color scheme."><meta name=og:image:type content="image/png"><meta name=og:type content="website"><link rel=stylesheet href=https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/template.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.3.2/styles/default.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css><script src=https://code.jquery.com/jquery-3.5.1.min.js></script><script src=https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.cookie.js></script><script src=https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.hoverIntent.minified.js></script><script src=https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link href=/style.css rel=stylesheet><link href=https://cdn.rawgit.com/ryangrose/easy-pandoc-templates/948e28e5/css/elegant_bootstrap.css rel=stylesheet><script src=https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/jquery.sticky-kit.js></script><script data-ad-client=ca-pub-9962024266760159 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script src=/script.js></script><link rel=icon href=/favicon.ico type=image/x-icon><meta name=generator content="pandoc"><title>Signals &lsaquo; antipattern &lsaquo; Django antipatterns</title></head><body><a class=github-fork-ribbon href=https://github.com/hapytex/django-antipatterns data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a><article><div class="navbar navbar-static-top"><div class=navbar-inner><div class=container><nav aria-label=section><ol class=breadcrumb><li class=breadcrumb-item><a href=/><i class="fas fa-home"></i></a><li class=breadcrumb-item><a href=/antipattern.html><i class="fas fa-ban"></i>&nbsp;
antipattern</a><li class="breadcrumb-item active" aria-current=page>Signals</ol></nav><ul class="nav pull-right doc-info"><li><div class=rating data-rating=3>severity:
<i class=star-1>★</i>
<i class=star-2>★</i>
<i class=star-3>★</i>
<i class=star-4>★</i>
<i class=star-5>★</i></div></ul></div></div></div><div class=container><div class=row><div class=span12><p>Django has a sophisticated system to trigger certain logic when you save, delete, change many-to-many relations, etc. Very often people make use of such signals and for some edge-cases these are indeed the only effective solution, but there are only a few cases where using signals is appropriate.<h1 id=why-is-it-a-problem>Why is it a problem?</h1><p>Signals have a variety of problems and unforeseen consequences. In the below sections, we list a few.<h2 id=signals-can-be-circumvented>Signals can be circumvented</h2><p>One of the main problems with signals is that signals do <em>not</em> always run. Indeed the <code>pre_save</code> and <code>post_save</code> signals will <em>not</em> run when we save or update objects in bulk. For example if we create multiple <code>Post</code>s with:<pre class=python><code>Post.objects.<b>bulk_create(</b>[
    Post(title='foo'),
    Post(title='bar'),
    Post(title='qux')
]<b>)</b></code></pre><p>then the signals do not run. The same happens when you update posts, for example with:<pre class=python><code>Post.objects.all().<b>update(</b>views=0<b>)</b></code></pre><p>Often people assume that signals <em>will</em> run in that case, and for example perform calculations with the signals: they recalculate a certain field, based on the updated values. Since one can update a field <em>without</em> triggering the the corresponding signals, then this results in an inconsistent value. Signals thus give a <em>false sense of security</em> that the handler will indeed update the object accordingly.<h2 id=signals-are-request-unaware>Signals are request unaware</h2><p>Every now and then people try to implement a signal that needs a request object to perform a certain piece of logic. For example one might want to send an email each time a certain model is created to the person that made the HTTP request.<p>Django’s signal processing however does not capture the request. This makes sense since these signals get fired by models that are created, updated, removed, etc. and models are request unaware as well.<p>The fact that these are request unaware makes it harder to implement certain behavior. For example a signal that updates the <code>owner</code> field of a model object with the currently logged in user. Strictly speaking it <em>is</em> possible to implement this, for example by inspecting the call stack. If the signal is triggered by a view, eventually one will find a call to that view, and thus one can obtain the <code>request</code> object. Another way to do this would be to implement middleware that keeps track of the user that makes the request, and then uses that, but that will introduce a <em>global state</em> antipattern.<p>This thus means that while technically there are some ways to make signals request-aware these solutions are often <em>ugly</em> and furthermore can fail if a management command triggers the change.<h2 id=signals-can-raise-exceptions-and-break-the-code-flow>Signals can raise exceptions and break the code flow</h2><p>If the signals run, for example when we call <code>.save()</code> on a model object, then the triggers <em>will</em> run. Contrary to popular belief, signals do <em>not</em> run asynchronous, but in a synchronous manner: there is a list of functions and these will all run. A second problem is that these signals might raise an error, and this will thus result in the function that triggered the views, raising that error. Developers often do not take this into account.<p>If such error is raised, then eventually the <code>.save()</code> call will raise an error. Even if the developer takes this into account, it is hard to anticipate on the consequences: if there are multiple handlers for the same signal, then some of the handlers can have made changes whereas others might not have been invoked. It thus makes it more complicated to repair the object, since the handlers might already have changed the object partially.<h2 id=signals-can-result-in-infinite-recursion>Signals can result in infinite recursion</h2><p>It is also rather easy to get stuck in an infinite loop with signals. If we for example have a model of a <code>Profile</code> with a signal that will remove the <code>User</code> if we remove the <code>Profile</code>:<pre class=python><code>from django.db import models
from django.db.models.signals import pre_delete
from django.dispatch import receiver

class Profile(models.Model):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE
    )

# &hellip;

@receiver(pre_delete, sender=Profile)
def delete_profile(sender, instance, using):
    instance.user.delete()</code></pre><p>If we now remove a <code>Profile</code>, this will get stuck in an infinite loop. Indeed, first we start removing a <code>Profile</code>. This will trigger the signal to run, which will remove the related user object. But Django will look what to do when removing the user, and it thus will <em>first</em> remove the <code>Profile</code> again triggering the signal. It is easy to end up with infinite recursion when defining signals. Especially if we use signals on two models that are related to each other.<h2 id=signals-run-before-updating-many-to-many-relations>Signals run before updating many-to-many relations</h2><p>The <code>pre_save</code> and <code>post_save</code> signals of an object run immediately before and after an object is saved to the database. If we have a model with a <code>ManyToManyField</code>, then when we create that object and the signals run, the <code>ManyToManyField</code> is <em>not</em> yet populated. This is because a <code>ModelForm</code> first needs to create the object, before that object has a primary key and thus can start populating the many-to-many relation. If we for example have two models <code>Author</code> and <code>Book</code> with a many-to-many relation, and we want to use a signal that counts the number of books an <code>Author</code> has written, then the following signal will not work when we create an <code>Author</code>, and the form also to specify the books:<pre class=python><code>from django.db.models.signals import pre_save
from django.dispatch import receiver

@receiver(pre_save, sender=Author)
def save_author(sender, instance, created, raw, using, update_fields):
    instance.num_books = instance.books.count()</code></pre><p>Regardless whether we use a <code>pre_save</code> or <code>post_save</code> signal, at that moment in time <code>instance.books.all()</code> is an empty queryset.<h2 id=signals-make-altering-objects-less-predictable>Signals make altering objects less predictable</h2><p>Even if only one handler is attached to the the signal, and that handler can never raise an error, the handler still is often not an elegant solution. Another developer might not be aware of its existence, since it has only a “weak” binding to the model, and thus it makes the effect of saving an object less predictable.<h2 id=signals-do-not-run-when-other-programs-make-changes>Signals do not run when other programs make changes</h2><p>Finally other programs can also make changes to the database, and thus will not trigger the signals, and this eventually could lead to the database being in an inconsistent state. Another program could for example create a new book for an author, but might not update the field in the <code>Author</code> model that keeps track of the number of books written by that author. It will be quite hard to “translate” all the handlers in Django to other programs that interact with the same database.<h1 id=what-can-be-done-to-resolve-the-problem>What can be done to resolve the problem?</h1><p>Often it is better to avoid using signals. One can implement a lot of logic <em>without</em> signals.<h2 id=calculating-properties-on-demand>Calculating properties on-demand</h2><p>The most robust way to count the number of <code>Book</code>s of an <code>Author</code> is <em>not</em> to store the number of books in a field, but use <a href=https://docs.djangoproject.com/en/dev/ref/models/querysets/#annotate><strong><code>.annotate(…)</code></strong> [Django-doc]</a> to each time annotate the <code>Author</code>s with the number of <code>Book</code>s they have written. We thus can make a query that looks like:<pre class=python3><code>from django.db.models import <b>Count</b>

Author.objects.annotate(
    <b>num_books=Count('books')</b>
)</code></pre><p>Often if the number of <code>Book</code>s is not that large, this will still scale quite well. It is more robust: if somehow another program removed a book, or a view was triggered that somehow circumvented the update logic, it will still work with the correct amount of books.<p>Here of course we each time recalculate the number of <code>Book</code>s per <code>Author</code> when we query. If the number of <code>Book</code>s and <code>Author</code>s grows, then this can become a performance bottleneck.<h2 id=encapsulating-update-logic-in-the-viewform-and-modeladmin>Encapsulating update logic in the view/form and ModelAdmin</h2><p>Another option might be to encapsulate the handler logic in a specific function. For example if we want to count the number of books of an <code>Author</code> each time we save/update a <code>Book</code>, we can implement the logic:<pre class=python3><code>def update_book(book):
    author = book.author
    author.num_books = author.books.count()
    author.save()</code></pre><p>and then we can call this function in the views where we create/update the book. For example:<pre class=python><code>def my_view(request):
    if request.method == 'POST':
        form = BookForm(request.POST, request.FILES)
        if form.is_valid():
            book = form.save()
            <b>update_book(</b>book<b>)</b>
            # &hellip;
        # &hellip;
    # &hellip;</code></pre><p>we can also construct a mixin that we can use in class-based views and the <code>ModelAdmin</code>:<pre class=python><code>from django.contrib import admin

class MyModelAdmin(admin.ModelAdmin):
    
    def save_model(self, request, obj, form, change):
        <b>update_book(</b>obj<b>)</b>
        super().save_model(request, obj, form, change)</code></pre><p>If the task takes too much time, you can set up a queue where a message is queued that will then trigger a task to update the data. This is however not something specific to encapsulate logic into a function: if you work with signals, then these signals can go in timeout as well, and thus render the server irresponsive.<h1 id=extra-tips>Extra tips</h1><p>Signals can still be a good solution if you want to handle events raised by a <em>third party</em> Django application. In many cases, this is the only effective way to handle certain events. For example the <code>auth</code> module provides <a href=https://docs.djangoproject.com/en/dev/ref/contrib/auth/#module-django.contrib.auth.signals>signals when the user logs in, logs out, or fails to log in [Django-doc]</a> these signals are typically more reliable, since these are not triggered by the ORM. Often for third party applications signals are an effective way to communicate with these applications.</p><script nonce data-name=BMC-Widget src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-id=hapytex data-description="Support me on Buy me a coffee!" data-message="Thank you for visiting." data-color=#FFDD00 data-position=Right data-x_margin=18 data-y_margin=18></script></div></div></div><script src=https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js integrity="sha512-zPB79j2C+3sFS9zcA3vg/z6bVKzJVEyu9pY5w89akQRys76zpAT2t6S3wZKla3QQ14O5l/Yt0RUQ/DHXx82Y5g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.3.2/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><script>anchors.options={placement:'left',visible:'hover',icon:'¶'};anchors.add('h1,h2,h3');</script></article></body></html>